package database

import java.sql.Connection
import java.sql.ResultSet
import java.sql.Statement
import java.util.Properties
import javax.sql.DataSource

import org.h2.jdbcx.JdbcConnectionPool

import scala.util.Try

/**
  * Created by beochot on 4/22/2017.
  */
object Database {
    def init(properties: Properties) = {
        this.connectionPool = JdbcConnectionPool.create(
            properties.getProperty("url"), properties.getProperty("username"), properties.getProperty("password"))
        //Temporary fix
        this.connectionPool.setMaxConnections(9999)
    }
    private var connectionPool: JdbcConnectionPool = null
    private var currentConnection: Connection = null

    /**
      * Opens new thread-local connection
      */
    def open(): Connection = {
        currentConnection = connectionPool.getConnection
        currentConnection
    }

    /**
      * Returns current thread-local connection
      */
    def current(): Connection = currentConnection

    /**
      * Closes current thread-local connection
      */
    def close() {
        currentConnection.close()
    }

    def transaction[T](block: () => T): T = {

        val connection = Database.open()
        connection.setAutoCommit(false)

        try {
            val result = block()
            connection.commit()

            return result
        } catch {
            case e: Exception => {
                if (!connection.isClosed)
                    connection.rollback()
                throw e
            }

        } finally {
            connection.setAutoCommit(true)
            Database.close()
        }
    }

    def prepare(sql: String, autogenerateKey: Boolean = false) = {
        val connection = Database.open()
        val autoGeneratedKeysFlag = if (autogenerateKey) Statement.RETURN_GENERATED_KEYS else Statement.NO_GENERATED_KEYS
        connection.prepareStatement(sql, autoGeneratedKeysFlag)
    }

    def findOne[T](sql: String, extractor: (ResultSet) => T): Option[T] = {
        val resultSet = prepare(sql).executeQuery()

        if (resultSet.next()) {
            return Option(extractor(resultSet))
        }

        None
    }

    def findAll[T](sql: String, extractor: (ResultSet) => T): List[T] = {
        val resultSet = prepare(sql).executeQuery()
        val iterator = new Iterator[T] {
            def hasNext = resultSet.next()

            def next() = extractor(resultSet)
        }.toStream

        iterator.toList
    }

    def insert[T](sql: String, block: (ResultSet) => T): Option[T] = {
        val statement = prepare(sql, autogenerateKey = true)
        try {
            statement.executeUpdate()
            val resultSet = statement.getGeneratedKeys
            if (resultSet.next()) {
                return Option(block(resultSet))
            }
            None
        } catch {
            case e: Exception => None
        }
    }

    def update(sql: String): Int =
        prepare(sql).executeUpdate()

}



